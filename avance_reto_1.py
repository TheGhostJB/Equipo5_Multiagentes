# -*- coding: utf-8 -*-
"""Sistemas Multiagentes : 1a demo del reto en 2D.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14xAY0EimfgTXHrooiyQXeVuxh9KnJ51r
"""



"""# Sistemas Multiagentes : 1a demo del reto en 2D

"""

!pip install matplotlib numpy agentpy

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
import heapq
from collections import deque
import random

# Model design
import agentpy as ap
import numpy as np
from collections import deque
import heapq

# Visualization
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import IPython

class ObstacleTractor(ap.Agent):
    """Static or slowly moving obstacle tractor"""

    def setup(self):
        self.width = self.p.obstacle_width
        self.length = self.p.obstacle_length
        self.velocity = np.array([0.0, 0.0])

        # Small random motion
        if self.model.nprandom.random() < 0.5:  # 30% of tractors move slowly
            angle = self.model.nprandom.random() * 2 * np.pi
            speed = self.p.obstacle_speed
            self.velocity = np.array([np.cos(angle), np.sin(angle)]) * speed

    def setup_pos(self, space):
        self.space = space
        self.pos = space.positions[self]

    def update_position(self):
        """Move obstacle slightly with boundary checking"""
        if np.linalg.norm(self.velocity) > 0:
            new_pos = self.pos + self.velocity

            # Bounce off walls
            for i in range(2):
                if new_pos[i] < 0 or new_pos[i] > self.space.shape[i]:
                    self.velocity[i] *= -1
                    new_pos[i] = np.clip(new_pos[i], 0, self.space.shape[i])

            self.space.move_to(self, new_pos)

class MainTractor(ap.Agent):
    """Main tractor that navigates from A to B using A* pathfinding"""

    def setup(self):
        self.width = self.p.tractor_width
        self.length = self.p.tractor_length
        self.path = []
        self.path_index = 0
        self.reached_target = False
        self.visited_cells = set()
        self.total_distance = 0
        self.replan_counter = 0

    def setup_pos(self, space):
        self.space = space
        self.pos = space.positions[self]
        self.start = np.array(self.pos)
        self.target = np.array([self.p.size - 5, self.p.size - 5])

    def heuristic(self, a, b):
        """Manhattan distance heuristic"""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def is_collision(self, pos):
        """Check if position collides with any obstacle"""
        for obstacle in self.model.obstacles:
            obs_pos = obstacle.pos
            # Simple rectangular collision detection
            dist = np.linalg.norm(pos - obs_pos)
            if dist < (self.width + obstacle.width) / 2 + self.p.safety_margin:
                return True
        return False

    def get_neighbors(self, pos):
        """Get valid neighboring positions (8-directional movement)"""
        neighbors = []
        directions = [
            (0, 1), (1, 0), (0, -1), (-1, 0),  # Cardinal
            (1, 1), (1, -1), (-1, 1), (-1, -1)  # Diagonal
        ]

        for dx, dy in directions:
            new_pos = (pos[0] + dx, pos[1] + dy)
            if (0 <= new_pos[0] < self.p.size and
                0 <= new_pos[1] < self.p.size):
                new_pos_array = np.array([float(new_pos[0]), float(new_pos[1])])
                if not self.is_collision(new_pos_array):
                    neighbors.append(new_pos)

        return neighbors

    def a_star_search(self, start, goal):
        """A* pathfinding algorithm"""
        start_tuple = (int(start[0]), int(start[1]))
        goal_tuple = (int(goal[0]), int(goal[1]))

        open_set = []
        heapq.heappush(open_set, (0, start_tuple))

        came_from = {}
        g_score = {start_tuple: 0}
        f_score = {start_tuple: self.heuristic(start_tuple, goal_tuple)}

        while open_set:
            current = heapq.heappop(open_set)[1]

            if self.heuristic(current, goal_tuple) < 2:
                # Reconstruct path
                path = []
                while current in came_from:
                    path.append(np.array([float(current[0]), float(current[1])]))
                    current = came_from[current]
                path.append(start)
                return path[::-1]

            for neighbor in self.get_neighbors(current):
                tentative_g = g_score[current] + 1

                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self.heuristic(neighbor, goal_tuple)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))

        return []  # No path found

    def plan_path(self):
        """Plan path from current position to target"""
        self.path = self.a_star_search(self.pos, self.target)
        self.path_index = 0
        self.replan_counter += 1

    def update_position(self):
        """Follow the planned path"""
        if self.reached_target:
            return

        # Check if we need to replan (obstacle moved into path)
        if self.path_index < len(self.path):
            next_pos = self.path[self.path_index]
            if self.is_collision(next_pos):
                self.plan_path()
                return

        # If no path or reached end of path, replan
        if not self.path or self.path_index >= len(self.path):
            if np.linalg.norm(self.pos - self.target) < 2:
                self.reached_target = True
                print(f"Target reached at t={self.model.t}!")
                print(f"Total distance traveled: {self.total_distance:.2f}")
                print(f"Replanning events: {self.replan_counter}")
                return
            self.plan_path()
            return

        # Move to next position in path
        next_pos = self.path[self.path_index]

        # Track visited cells for overlap analysis
        cell = (int(self.pos[0]), int(self.pos[1]))
        self.visited_cells.add(cell)

        # Calculate distance
        distance = np.linalg.norm(next_pos - self.pos)
        self.total_distance += distance

        self.space.move_to(self, next_pos)
        self.path_index += 1

class TractorModel(ap.Model):
    """Multi-agent tractor navigation model with A* pathfinding"""

    def setup(self):
        """Initialize the environment with obstacles and main tractor"""

        self.space = ap.Space(self, shape=[self.p.size, self.p.size])

        # Create obstacle tractors
        self.obstacles = ap.AgentList(self, self.p.n_obstacles, ObstacleTractor)
        self.space.add_agents(self.obstacles, random=True)
        self.obstacles.setup_pos(self.space)

        # Create main tractor at start position
        self.tractor = MainTractor(self)
        self.space.add_agents([self.tractor], positions=[np.array([5.0, 5.0])])
        self.tractor.setup_pos(self.space)

        # Initial path planning
        self.tractor.plan_path()

        # Metrics
        self.path_history = []

    def step(self):
        """Execute one simulation step"""

        # Move obstacles slightly
        self.obstacles.update_position()

        # Move main tractor
        self.tractor.update_position()

        # Record path for visualization
        self.path_history.append(np.array(self.tractor.pos))

    def end(self):
        """Calculate final metrics"""
        visited = len(self.tractor.visited_cells)
        total_cells = len(self.path_history)
        overlap = total_cells - visited
        overlap_pct = (overlap / total_cells * 100) if total_cells > 0 else 0

        print(f"\n=== Simulation Complete ===")
        print(f"Path length: {total_cells} cells")
        print(f"Unique cells visited: {visited}")
        print(f"Overlapping cells: {overlap}")
        print(f"Overlap percentage: {overlap_pct:.2f}%")

def animation_plot_single(m, ax):
    """Plot single frame of animation"""
    ax.clear()
    ax.set_title(f"Navegación del tractor - Paso {m.t}")
    ax.set_xlim(0, m.p.size)
    ax.set_ylim(0, m.p.size)
    ax.set_xlabel('Posición en X')
    ax.set_ylabel('Posición en Y')
    ax.grid(True, alpha=0.3)

    # Draw obstacles
    for obstacle in m.obstacles:
        pos = obstacle.pos
        rect = patches.Rectangle(
            (pos[0] - obstacle.width/2, pos[1] - obstacle.length/2),
            obstacle.width, obstacle.length,
            linewidth=1, edgecolor='red', facecolor='lightcoral', alpha=0.7
        )
        ax.add_patch(rect)

    # Draw path history
    if len(m.path_history) > 1:
        path_array = np.array(m.path_history)
        ax.plot(path_array[:, 0], path_array[:, 1], 'b-', alpha=0.3, linewidth=1, label='Camino')

    # Draw planned path
    if m.tractor.path:
        path = np.array(m.tractor.path)
        ax.plot(path[:, 0], path[:, 1], 'g--', alpha=0.5, linewidth=1, label='Planeado')

    # Draw main tractor
    pos = m.tractor.pos
    rect = patches.Rectangle(
        (pos[0] - m.tractor.width/2, pos[1] - m.tractor.length/2),
        m.tractor.width, m.tractor.length,
        linewidth=2, edgecolor='blue', facecolor='lightblue', alpha=0.9
    )
    ax.add_patch(rect)

    # Draw start and target
    ax.plot(5, 5, 'go', markersize=10, label='Inicio')
    ax.plot(m.p.size-5, m.p.size-5, 'r*', markersize=15, label='Objetivo')

    ax.legend(loc='upper left', fontsize=8)

def animation_plot(m, p):
    """Create animation"""
    fig, ax = plt.subplots(figsize=(10, 10))
    animation = ap.animate(m(p), fig, ax, animation_plot_single)
    return IPython.display.HTML(animation.to_jshtml(fps=10))

# Simulation parameters
parameters = {
    'size': 50,
    'seed': 123,
    'steps': 60,
    'n_obstacles': 15,
    'tractor_width': 2,
    'tractor_length': 2,
    'obstacle_width': 2.5,
    'obstacle_length': 2.5,
    'obstacle_speed': 0.05,
    'safety_margin': 1.5
}

# Generate animation (this will run the simulation)
animation_plot(TractorModel, parameters)